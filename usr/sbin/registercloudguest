#!/usr/bin/python

# Copyright (c) 2015, SUSE LLC, All rights reserved.
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 3.0 of the License, or (at your option) any later version.
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# Lesser General Public License for more details.
# You should have received a copy of the GNU Lesser General Public
# License along with this library.

"""This script obtains information from the configured region server in the
   cloud environment and uses the information to register the guest with
   the SMT server based on the information provided by the region server.

   The configuration is in ini format and is located in
   /etc/regionserverclnt.cfg"""

import ConfigParser
import base64
import glob
import logging
import os
import pickle
import random
import requests
import stat
import subprocess
import sys
import time
import uuid

import cloudregister.registerutils as utils

from cloudregister import smt
from lxml import etree
from M2Crypto import X509


# ----------------------------------------------------------------------------
def add_region_server_args_to_URL(api, cfg):
    """Add arguments from the instance to the given api URL.
       The arguments are generated by a plugin that must provide the
       generateRegionSrvArgs() function.
    """

    if cfg.has_section('instance'):
        module = None
        if cfg.has_option('instance', 'instanceArgs'):
            module = cfg.get('instance', 'instanceArgs')
        if module and module != 'none':
            try:
                mod = __import__('cloudregister.%s' % module, fromlist=[''])
                regionSrvArgs = '?' + mod.generateRegionSrvArgs()
                logging.info('Region server arguments: %s' % regionSrvArgs)
                api += regionSrvArgs
            except:
                msg = 'Configured instanceArgs module could not be loaded. '
                msg += 'Continuing without additional arguments.'
                logging.warning(msg)

    return api


# ----------------------------------------------------------------------------
def get_config(configFile=None):
    """Read configuration file and return a config object"""
    if not configFile:
        configFile = '/etc/regionserverclnt.cfg'

    cfg = ConfigParser.RawConfigParser()
    try:
        parsed = cfg.read(configFile)
    except:
        print 'Could not parse configuration file %s' % configFile
        type, value, tb = sys.exc_info()
        print value.message
        sys.exit(1)

    if not parsed:
        print 'Error parsing config file: %s' % configFile
        sys.exit(1)

    return cfg


# ----------------------------------------------------------------------------
def get_configured_smt(smt_servers, known_hosts):
    """Check if an entry for the given SMT server exists."""
    for smt in smt_servers:
        smt_ip = smt.get_ip()
        smt_fqdn = smt.get_FQDN()
        for entry in known_hosts:
            if entry.find(smt_ip) != -1 and entry.find(smt_fqdn) != -1:
                return smt

    return None


# ----------------------------------------------------------------------------
def get_products():
    products = []
    try:
        cmd = subprocess.Popen(
            ["zypper", "-x", "products"], stdout=subprocess.PIPE
        )
        product_xml = cmd.communicate()
    except:
        errMsg = 'Could not get product list %s' % cmd[1]
        logging.error(errMsg)
        return

    # Detrmine the base product
    baseProdSet = '/etc/products.d/baseproduct'
    baseprodName = None
    if os.path.islink(baseProdSet):
        baseprod = os.path.realpath(baseProdSet)
        baseprodName = baseprod.split(os.sep)[-1].split('.')[0]
    else:
        errMsg = 'No baseproduct installed system cannot be registerd'
        logging.error(errMsg)
        return

    product_tree = etree.fromstring(str(product_xml[0]))
    for child in product_tree.find("product-list"):
        name = child.attrib['name']
        if name == baseprodName:
            continue
        vers = child.attrib['version']
        arch = child.attrib['arch']
        prod = name + "/" + vers + "/" + arch
        if prod not in products:
            products.append(prod)

    return products


# ----------------------------------------------------------------------------
def import_CA(smtCA_request):
    key_chain = '/usr/share/pki/trust/anchors/registration_server.pem'
    logging.info('Writing SMT rootCA: %s' % key_chain)
    try:
        smtCAFile = open(key_chain, 'w')
        smtCAFile.write(smtCA_request.text)
        smtCAFile.close()
    except IOError:
        errMsg = 'Could not store SMT certificate'
        logging.error(errMsg)
        return 0
    try:
        ca_update = ["update-ca-certificates"]
        cmd = subprocess.Popen(
            ca_update,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE
        )
        logging.info('Updating CA certificates: %s' % ca_update)
        cmd.communicate()
    except:
        errMsg = 'Could not update certificates %s' % cmd[1]
        logging.error(errMsg)
        return 0
    return 1


# ----------------------------------------------------------------------------
def is_zypper_running():
    """Check if zypper is running"""
    # Zypper doesn't remove it's pid file, need to consult the process table
    zypper_pid = utils.get_zypper_pid()
    if zypper_pid != '':
        return True

    return False


# ----------------------------------------------------------------------------
def update_hosts_entry(smt_servers):
    """If we can find a matching server modify the entry in /etc/hosts"""
    current_smt = utils.get_current_smt()
    if not current_smt:
        return None

    for smt in smt_servers:
        if smt.get_ip() == current_smt.get_ip():
            continue
        if utils.smt_servers_are_equivalent(current_smt, smt):
            utils.replace_hosts_entry(current_smt, smt)
            return smt

    return None


# ----------------------------------------------------------------------------
def is_x509_fingerprint_valid(smtCA_request, fingerprint):
    try:
        x509 = X509.load_cert_string(str(smtCA_request.text))
        x509_fingerprint = x509.get_fingerprint('sha1')
    except:
        errMsg = 'Could not read X509 fingerprint from cert'
        logging.error(errMsg)
        return 0
    if x509_fingerprint != fingerprint.replace(':', ''):
        errMsg = 'Fingerprint could not be verified'
        logging.error(errMsg)
        return 0
    return 1


# ----------------------------------------------------------------------------
# Support custom config file with -f command line option
configFile = None

if '-f' in sys.argv:
    idx = sys.argv.index('-f')
    configFile = sys.argv[idx+1]

force_new_registration = None
if '--force-new' in sys.argv:
    force_new_registration = True

if '--delay' in sys.argv:
    arg_index = sys.argv.index('--delay')
    delay_time = sys.argv[arg_index + 1]
    time.sleep(int(delay_time))

cfg = get_config(configFile)
utils.start_logging()

if force_new_registration:
    logging.info('Forced new registration')

# Get the API to use
api = cfg.get('server', 'api')
logging.info('Using API: %s' % api)

# Add regionserver arguments
api = add_region_server_args_to_URL(api, cfg)

# Get the SMT server information from one of the configured region servers
response = None
# Get the location of the cert files for the region servers
cert_dir = cfg.get('server', 'certLocation')
region_servers = cfg.get('server', 'regionsrv').split(',')
random.shuffle(region_servers)
for srv in region_servers:
    srvName = srv.strip()
    logging.info('Using region server: %s' % srvName)
    certFile = cert_dir + '/' + srvName + '.pem'
    if not os.path.isfile(certFile):
        logging.info('No cert found: %s skip this server' % certFile)
        continue
    try:
        response = requests.get('https://%s/%s' % (srvName, api),
                                verify=certFile,
                                timeout=15.0)
        if response.status_code == 200:
            break
        else:
            logging.error('=' * 20)
            logging.error('Server returned: %d' % response.status_code)
            logging.error(response.text)
            logging.error('=' * 20)
    except:
        logging.error('No response from: %s' % srvName)
        if srv == region_servers[-1]:
            logging.error('None of the servers responded')
            logging.error('\tAttemted: %s' % region_servers)
            logging.error('Exiting without registration')
            sys.exit(1)
        continue

if not response.status_code == 200:
    logging.error('Request not answered by any server, exiting')
    sys.exit(1)

smtDataRoot = etree.fromstring(response.text)
known_smt_servers = []
smt_count = 1
if not os.path.exists(utils.REGISTRATION_DATA_DIR):
    os.mkdir(utils.REGISTRATION_DATA_DIR)
for child in smtDataRoot:
    smt_server = smt.SMT(child)
    store_file_name = (utils.REGISTRATION_DATA_DIR
                       + utils.AVAILABLE_SMT_SERVER_DATA_FILE_NAME % smt_count)
    utils.store_smt_data(store_file_name, smt_server)
    known_smt_servers.append(smt_server)

# This is a forced re-registration clear out all existing data
if force_new_registration:
    if is_zypper_running():
        msg = 'zypper is running: Registration with the update '
        msg += 'infrastructure is only possible if zypper is not running.\n'
        msg += 'Please re-run the force registration process after zypper '
        msg += 'has completed'
        print msg
        sys.exit(1)
    utils.remove_registration_data(known_smt_servers)

# Check if we have some kind of configuartion
known_hosts = open('/etc/hosts', 'r').readlines()
configured_smt_server = get_configured_smt(known_smt_servers, known_hosts)
if configured_smt_server:
    if utils.is_registered(configured_smt_server):
        alive = utils.get_smt_cert(configured_smt_server.get_ip())
        if alive and alive.status_code == 200:
            msg = 'Instance is registered, and SMT server is reachable, '
            msg += 'nothing to do'
            logging.info(msg)
            sys.exit(0)
        else:
            # The configured server is not resposive, lets check if we can
            # find a server that matches.
            new_target = update_hosts_entry(known_smt_servers)
            alive = None
            if new_target:
                alive = utils.get_smt_cert(new_target.get_ip())
            if alive and alive.status_code == 200:
                utils.store_smt_data(
                    utils.get_registered_smt_file_path(),
                    new_target)
                msg = 'Instance is registered, switched to new SMT server: '
                msg += new_target.get_ip()
                logging.info(msg)
                sys.exit(0)
            else:
                utils.remove_registration_data(known_smt_servers)
    else:
        # We are in a weird state with remnants in /etc/hosts but
        # no registration
        utils.remove_registration_data(known_smt_servers)

# Figure out which server is responsive and use it as registration target
registration_target = None
tested_smt_servers = []
for smt in known_smt_servers:
    smt_ip = smt.get_ip()
    tested_smt_servers.append(smt_ip)
    alive = utils.get_smt_cert(smt_ip)
    if alive and alive.status_code == 200:
        registration_target = smt
        # Use the first server that responds
        break

if not registration_target:
    logging.error('None response from: %s' % tested_smt_servers)
    sys.exit(1)

# Add the target SMT server to the hosts file
smt_hosts_entry_comment = '\n# Added by SMT registration do not remove, '
smt_hosts_entry_comment += 'retain comment as well\n'
hosts = open('/etc/hosts', 'a')
hosts.write(smt_hosts_entry_comment)
entry = '%s\t%s\t%s\n' % (registration_target.get_ip(),
                          registration_target.get_FQDN(),
                          registration_target.get_name())
hosts.write(entry)
hosts.close()
logging.info('Modified /etc/hosts, added: %s' % entry)

# Create location to store data if it does not exist
if not os.path.exists(utils.REGISTRATION_DATA_DIR):
    os.system('mkdir -p %s' % utils.REGISTRATION_DATA_DIR)

# Write the data of the current target server
utils.store_smt_data(utils.get_registered_smt_file_path(), registration_target)

# Check if we need to send along any instance data
instance_data_filepath = utils.REGISTRATION_DATA_DIR + str(uuid.uuid4())
if cfg.has_section('instance'):
    if cfg.has_option('instance', 'dataProvider'):
        instance_data_cmd = cfg.get('instance', 'dataProvider')
        cmd = instance_data_cmd.split()[0]
        if cmd != 'none':
            if cmd[0] != '/':
                try:
                    p = subprocess.Popen(
                        ['which %s' % cmd],
                        stdout=subprocess.PIPE,
                        stderr=subprocess.PIPE,
                        close_fds=True
                    )
                except:
                    errMsg = 'Could not find configured dataProvider: %s' % cmd
                    logging.error(errMsg)
            if os.access(cmd, os.X_OK):
                os.system("%s > %s" % (instance_data_cmd,
                                       instance_data_filepath))
            else:
                msg = 'Configured dataProvider "%s" is not executable' % cmd
                logging.error(msg)

register11 = '/usr/lib/suseRegister/bin/clientSetup4SMT.sh'
register12 = '/usr/sbin/SUSEConnect'
if (os.path.exists(register11) and os.access(register11, os.X_OK)):
    cmd = register11
    cmd += ' --host %s ' % registration_target.get_FQDN()
    cmd += '--fingerprint %s ' % registration_target.get_fingerprint()
    cmd += '--yes '

    if os.path.exists(instance_data_filepath):
        cmd += '--regdata %s' % instance_data_filepath

    if force_new_registration:
        cmd += ' > /dev/null 2>&1'

    logging.info('Registration: %s' % cmd)
    res = os.system(cmd)

    if res:
        logging.error('Registration failed')
        sys.exit(1)

    # registration was successful, let's check if the repos do
    # really exist and if not complete the registration by calling
    # suse_register with the restore-repos option
    reposExist = utils.has_repos(registration_target.get_FQDN())
    if not reposExist:
        cmd = "suse_register --restore-repos"
        res = os.system(cmd)

    if res:
        logging.info('Repositories were not restored')

elif (os.path.exists(register12) and os.access(register12, os.X_OK)):
    # get product list
    products = get_products()
    if products == None:
        sys.exit(1)
    
    smtCA_request = utils.get_smt_cert(registrationTarget.get_FQDN())
    if not smtCA_request:
        sys.exit(1)

    if not is_x509_fingerprint_valid(smtCA_request,
                                     registration_target.get_fingerprint()):
        logging.error('SMT certificate fingerprint verification failed')
        sys.exit(1)

    if not import_CA(smtCA_request):
        logging.error('SMT certificate import failed')
        sys.exit(1)

    # Register the base product first
    cmd = [register12, '--url', 'https://%s ' % registration_target.get_FQDN()]
    if os.path.exists(instance_data_filepath):
        cmd.append(' --instance-data')
        cmd.append(instance_data_filepath)
    p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    res = p.communicate()
    for entry in res:
        if entry.find('error') != -1:
            logging.error('Baseproduct registration failed')
            logging.error('\t%s' % entry)
            sys.exit(1)

    for product in products:
        cmd = register12
        cmd += ' --url https://%s ' % registration_target.get_FQDN()
        cmd += ' --product %s ' % product
        if os.path.exists(instance_data_filepath):
            cmd += ' --instance-data %s ' % instance_data_filepath

        logging.info('Registration: %s' % cmd)
        res = os.system(cmd)

        if res:
            logging.error('Registration failed')
            sys.exit(1)

else:
    logging.error('No registration executable found')
    sys.exit(1)

if os.path.exists(instance_data_filepath):
    os.unlink(instance_data_filepath)
