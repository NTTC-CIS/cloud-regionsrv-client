#!/usr/bin/python

# Copyright (c) 2015, SUSE LLC, All rights reserved.
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 3.0 of the License, or (at your option) any later version.
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# Lesser General Public License for more details.
# You should have received a copy of the GNU Lesser General Public
# License along with this library.

"""This script obtains information from the configured region server in the
   cloud environment and uses the information to register the guest with
   the SMT server based on the information provided by the region server.

   The configuration is in ini format and is located in
   etc/regionserverclnt.cfg"""

import ConfigParser
import base64
import glob
import logging
import os
import pickle
import random
import requests
import stat
import subprocess
import sys
import time
import uuid

from lxml import etree
from M2Crypto import X509

regDataDir = '/var/lib/cloudregister'
smtInfoFl = regDataDir + '/smtInfo.obj'

#==============================================================================
class SMT:
    """Store smt information"""
    def __init__(self, smtXMLNode):
        self.IP = smtXMLNode.attrib['SMTserverIP']
        self.FQDN = smtXMLNode.attrib['SMTserverName']
        self.fingerprint = smtXMLNode.attrib['fingerprint']

    #=================================================================
    def getDomainName(self):
        """Return the domain name for the server."""
        return self.FQDN.split('.', 1)[-1]

    #=================================================================
    def getFingerprint(self):
        """Return the fingerprint of the cert"""
        return self.fingerprint

    #=================================================================
    def getFQDN(self):
        """Return the fully qualified domain name"""
        return self.FQDN

    #=================================================================
    def getName(self):
        """Return the name"""
        return self.FQDN.split('.', 1)[0]

    #=================================================================
    def getIP(self):
        """Return the IP address"""
        return self.IP

#==============================================================================
def addRegionServerArgsToURL(api,cfg):
    """Add arguments from the instance to the given api URL.
       The arguments are generated by a plugin that must provide the
       generateRegionSrvArgs() function.
    """

    if cfg.has_section('instance'):
        module = None
        if cfg.has_option('instance', 'instanceArgs'):
            module = cfg.get('instance', 'instanceArgs')
        if module and module != 'none':
            try:
                mod = __import__('cloudregister.%s' %module, fromlist=[''])
                regionSrvArgs = '?' + mod.generateRegionSrvArgs()
                logging.info('Region server arguments: %s' %regionSrvArgs)
                api += regionSrvArgs
            except:
                msg = 'Configured instanceArgs module could not be loaded. '
                msg += 'Continuing without additional arguments.'
                logging.warning(msg)

    return api

#==============================================================================
def checkRegistration(smtServerName):
    """Check if the instance is already registerd"""
    credExist = hasCredentials()
    reposExist = hasRepos(smtServerName)
    if reposExist and credExist:
        return 1
    elif reposExist and not credExist:
        removeRepos(smtServerName)
    elif credExist and not reposExist:
        # We might have to rethink this when BYOL comes along and
        # registers with our SMT
        removeCredentials()

    return None

#==============================================================================
def cleanHostsFile(domainName):
    """Remove the smt server entry from the /etc/hosts file"""
    newHostContent = []
    content = open('/etc/hosts', 'r').readlines()
    smtAnnounceFound = None
    for entry in content:
        if entry.find('Added by SMT') != -1:
            smtAnnounceFound = True
            continue
        if smtAnnounceFound and entry.find(domainName) != -1:
            smtAnnounceFound = False
            continue
        newHostContent.append(entry)

    hostsFile = open('/etc/hosts', 'w')
    for entry in newHostContent:
        hostsFile.write(entry)
    hostsFile.close()

#==============================================================================
def getConfig(configFile=None):
    """Read configuration file and return a config object"""
    if not configFile:
        configFile = '/etc/regionserverclnt.cfg'
    
    cfg = ConfigParser.RawConfigParser()
    try:
        parsed = cfg.read(configFile)
    except:
        print 'Could not parse configuration file %s' %configFile
        type, value, tb = sys.exc_info()
        print value.message
        sys.exit(1)
	    
    if not parsed:
        print 'Error parsing config file: %s' %configFile
        sys.exit(1)

    return cfg

#==============================================================================
def getConfiguredSMT(smtServers, knownHosts):
    """Check if an entry for the given SMT server exists."""
    for smtSrv in smtServers:
        smtIP = smtSrv.getIP()
        smtFQDN = smtSrv.getFQDN()
        for entry in knownHosts:
            if entry.find(smtIP) != -1 and entry.find(smtFQDN) != -1:
                return smtSrv

    return None

#==============================================================================
def getProducts():
    products = []
    try:
        cmd = subprocess.Popen(
            ["zypper", "-x", "products"], stdout=subprocess.PIPE
        )
        product_xml = cmd.communicate()
    except:
        errMsg = 'Could not get product list %s' %cmd[1]
        logging.error(errMsg)
        return

    # Detrmine the base product
    baseProdSet = '/etc/products.d/baseproduct'
    baseprodName = None
    if os.path.islink(baseProdSet):
        baseprod = os.path.realpath(baseProdSet)
        baseprodName = baseprod.split(os.sep)[-1].split('.')[0]
    else:
        errMsg = 'No baseproduct installed system cannot be registerd'
        logging.error(errMsg)
        return
    
    product_tree = etree.fromstring(str(product_xml[0]))
    for child in product_tree.find("product-list"):
        name = child.attrib['name']
        if name == baseprodName:
            continue
        vers = child.attrib['version']
        arch = child.attrib['arch']
        prod = name + "/" + vers + "/" + arch
        if prod not in products:
            products.append(prod)
            
    return products

#==============================================================================
def getSMTCert(smtServer, retries=3):
    """Return the response object or none if the request fails."""

    cert = None
    attempts = 0
    while attempts < retries:
        attempts += 1
        try:
            cert = requests.get('http://%s/smt.crt' %smtServer)
        except:
            # No response from server
            logging.error('=' *20)
            logging.error('Attempt %s of %s' %(attempts, retries))
            logging.error('Server %s is unreachable' %smtServer)


    return cert

#==============================================================================
def getSMTFromStore():
    """Create an SMTinstance from the stored data."""
    if not os.path.exists(smtInfoFl):
        return None

    smtData = open(smtInfoFl, 'r')
    u = pickle.Unpickler(smtData)
    try:
        currentSMT = u.load()
    except:
        smtData.close()
        return None

    smtData.close()

    return currentSMT

#==============================================================================
def hasCredentials():
    """Check if a credentials file exists."""
    if (os.path.exists('/etc/zypp/credentials.d/NCCcredentials') or
    os.path.exists('/etc/zypp/credentials.d/SCCcredentials')):
        return 1

    return None

#==============================================================================
def hasRepos(smtServerName):
    """Check if repositories exist."""
    repoSrvName = smtServerName.replace('.','_')
    if (glob.glob('/etc/zypp/repos.d/*%s*' %repoSrvName)):
        return 1

    return None

#==============================================================================
def importCA(smtCA_request):
    key_chain = '/usr/share/pki/trust/anchors/registration_server.pem'
    logging.info('Writing SMT rootCA: %s' %key_chain)
    try:
        smtCAFile = open(key_chain, 'w')
        smtCAFile.write(smtCA_request.text)
        smtCAFile.close()
    except IOError:
        errMsg = 'Could not store SMT certificate'
        logging.error(errMsg)
        return 0
    try:
        ca_update = ["update-ca-certificates"]
        cmd = subprocess.Popen(
            ca_update,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE
        )
        logging.info('Updating CA certificates: %s' %ca_update)
        cmd.communicate()
    except:
        errMsg = 'Could not update certificates %s' %cmd[1]
        logging.error(errMsg)
        return 0
    return 1

#==============================================================================
def isRegistered(smtSrv):
    """Firgure out if any of the servers is known and this instan"""
    if checkRegistration(smtSrv.getFQDN()):
        return 1

    return None

#==============================================================================
def isZypperRunning():
    """Check if zypper is running"""
    # Zypper doesn't remove it's pid file, need to consult the process table
    zyppPIDCmd = ['ps', '-C', 'zypper', '-o', 'pid=']
    zyppPID = subprocess.Popen(zyppPIDCmd, stdout=subprocess.PIPE)
    pidData = zyppPID.communicate()
    pid = pidData[0]
    if pid != '':
        return True

    return False
    
#==============================================================================
def removeCredentials():
    """Remove the server generated credentials"""
    nccCreds = '/etc/zypp/credentials.d/NCCcredentials'
    sccCreds = '/etc/zypp/credentials.d/SCCcredentials'
    if os.path.exists(nccCreds):
        logging.info('Removing credentials: %s' %nccCreds)
        os.unlink(nccCreds)
    if os.path.exists(sccCreds):
        logging.info('Removing credentials: %s' %sccCreds)
        os.unlink(sccCreds)

    return 1

#==============================================================================
def removeRepos(smtServerName):
    """Remove the repositories for the given server"""
    repoSrvName = smtServerName.replace('.','_')
    repos = glob.glob('/etc/zypp/repos.d/*%s*' %repoSrvName)
    for repo in repos:
        logging.info('Removing repo: %s' %repo)
        os.unlink(repo)

    return 1

#==============================================================================
def removeRegistrationData(smtServers):
    """Reset the instance to an unregistered state"""
    smtData = regDataDir + '/' + smtInfoFl
    if os.path.exists(smtData):
        os.unlink(smtData)
    for smtSrv in smtServers:
        serverName = smtSrv.getFQDN()
        domainName = smtSrv.getDomainName()
        cleanHostsFile(domainName)
        removeRepos(serverName)
        removeCredentials()
        removeService(serverName)

#==============================================================================
def removeService(smtServerName):
    """Remove the service for the given SMT server"""
    repoSrvName = smtServerName.replace('.','_')
    srvs = glob.glob('/etc/zypp/services.d/*%s*' %repoSrvName)
    for srv in srvs:
        logging.info('Removing service: %s' %srv)
        os.unlink(srv)

    return 1

#==============================================================================
def replaceHostEntry(currentSMT, newSMTSrv):
    """Replace the information of the SMT server in /etc/hosts"""
    knownHosts = open('/etc/hosts', 'r').readlines()
    newHosts = ''
    curIP = currentSMT.getIP()
    for entry in knownHosts:
        if entry.find(curIP != -1):
            newHosts += '%s\t%s\t%s\n' %(newSMTSrv.getIP(),
                                         newSMTSrv.getFQDN(),
                                         newSMTSrv.getName())
            continue
        newHosts += entry

#==============================================================================
def startLogging():
    """Set up logging mechanism"""

    logFile = '/var/log/cloudregister'
    try:
        logging.basicConfig(
            filename=logFile,
            level=logging.INFO,
            format='%(asctime)s %(levelname)s:%(message)s'
        )
    except IOError:
        print 'Could not open log file ', logFile, ' for writing.'
        sys.exit(1)

#==============================================================================
def storeSMTData(smtSrv):
    """Store the given SMT server information"""
    
    smtData = open(smtInfoFl, 'w')
    os.fchmod(smtData.fileno(), stat.S_IREAD|stat.S_IWRITE)
    p = pickle.Pickler(smtData)
    p.dump(smtSrv)
    smtData.close()

#==============================================================================
def updateHostEntry(smtServers):
    """If we can find a matching server modify the entry in /etc/hosts"""
    currentSMT = getSMTFromStore()
    if not currentSMT:
        return None

    for smtSrv in smtServers:
        if smtSrv.getIP() == currentSMT.getIP():
            continue
        if (smtSrv.getFingerprint() == currentSMT.getFingerprint() and
            smtSrv.getFQDN() == currentSMT.getFQDN()):
            # If the fingerprints are the same we have the cert, if
            # the host name is the same the service and repos will match,
            # thus we can just switch the hosts entry. Use the first match
            replaceHostEntry(currentSMT, smtSrv)
            return smtSrv

    return None

#==============================================================================
def x509FingerPrintValid(smtCA_request, fingerprint):
    try:
        x509 = X509.load_cert_string(str(smtCA_request.text))
        x509_fingerprint = x509.get_fingerprint('sha1')
    except:
        errMsg = 'Could not read X509 fingerprint from cert'
        logging.error(errMsg)
        return 0
    if x509_fingerprint != fingerprint.replace(':',''):
        errMsg = 'Fingerprint could not be verified'
        logging.error(errMsg)
        return 0
    return 1

#==============================================================================
# Support custom config file with -f command line option
configFile = None

if '-f' in sys.argv:
    idx = sys.argv.index('-f')
    configFile = sys.argv[idx+1]

forceNewRegistration = None
if '--force-new' in sys.argv:
    forceNewRegistration = True

cfg = getConfig(configFile)
startLogging()

if forceNewRegistration:
    logging.info('Forced new registration')

# Get the API to use
api = cfg.get('server', 'api')
logging.info('Using API: %s' %api)

# Add regionserver arguments
api = addRegionServerArgsToURL(api,cfg)

# Get the SMT server information from one of the configured region servers
response = None
# Get the location of the cert files for the region servers
certDir = cfg.get('server', 'certLocation')
regionServers = cfg.get('server', 'regionsrv').split(',')
random.shuffle(regionServers)
for srv in regionServers:
    srvName = srv.strip()
    logging.info('Using region server: %s' %srvName)
    certFile = certDir + '/' + srvName + '.pem'
    if not os.path.isfile(certFile):
        logging.info('No cert found: %s skip this server' %certFile)
        continue
    try:
        response = requests.get('https://%s/%s' %(srvName, api),
                                verify=certFile,
                                timeout=15.0)
        if response.status_code == 200:
            break
        else:
            logging.error('=' *20)
            logging.error('Server returned: %d' %response.status_code)
            logging.error(response.text)
            logging.error('=' *20)
    except:
        logging.error('No response from: %s' %srvName)
        if srv == regionServers[-1]:
            logging.error('None of the servers responded')
            logging.error('\tAttemted: %s' %servers)
            logging.error('Exiting without registration')
            sys.exit(1)
        continue

if not response.status_code == 200:
    logging.error('Request not answered by any server, exiting')
    sys.exit(1)

smtDataRoot = etree.fromstring(response.text)
# TODO:
# Write the smtDataRoot to a file for the client fail over implementation
knownSMTServers = []
for child in smtDataRoot:
    knownSMTServers.append(SMT(child))

# This is a forced re-registration clear out all existing data
if forceNewRegistration:
    if isZypperRunning():
        msg = 'zypper is running: Registration with the update '
        msg += 'infrastructure is only possible if zypper is not running.\n'
        msg += 'Please re-run the force registration process after zypper '
        msg += 'has completed'
        print msg
        sys.exit(1)
    removeRegistrationData(knownSMTServers)

# Check if we have some kind of configuartion
knownHosts = open('/etc/hosts', 'r').readlines()
configuredSMTServer = getConfiguredSMT(knownSMTServers, knownHosts)
if configuredSMTServer:
    if isRegistered(configuredSMTServer):
        alive = getSMTCert(configuredSMTServer.getIP())
        if alive and alive.status_code == 200:
            msg = 'Instance is registered, and SMT server is reachable, '
            msg += 'nothing to do'
            logging.info(msg)
            sys.exit(0)
        else:
            # The configured server is not resposive, lets check if we can
            # find a server that matches.
            newTarget = updateHostEntry(knownSMTServers)
            alive = None
            if newTarget:
                alive = getSMTCert(newTarget.getIP())
            if alive and alive.status_code == 200:
                storeSMTData(newTarget)
                msg = 'Instance is registered, switched to new SMT server: '
                msg += newTarget.getIP()
                logging.info(msg)
                sys.exit(0)
            else:
                removeRegistrationData(knownSMTServers)
    else:
        # We are in a weird state with remnants in /etc/hosts but
        # no registration
        removeRegistrationData(knownSMTServers)

# Figure out which server is responsive and use it as registration target
registrationTarget = None
testedServers = []
for smtSrv in knownSMTServers:
    serverIP = smtSrv.getIP()
    testedServers.append(serverIP)
    alive = getSMTCert(serverIP)
    if alive and alive.status_code == 200:
        registrationTarget = smtSrv
        # Use the first server that responds
        break

if not registrationTarget:
    logging.error('None response from: %s' %testedServers)
    sys.exit(1)

    
# Add the target SMT server to the hosts file
smtAnnounceComment = '\n# Added by SMT registration do not remove, '
smtAnnounceComment += 'retain comment as well\n'
hosts = open('/etc/hosts', 'a')
hosts.write(smtAnnounceComment)
entry = '%s\t%s\t%s\n' %(registrationTarget.getIP(),
                         registrationTarget.getFQDN(),
                         registrationTarget.getName())
hosts.write(entry)
hosts.close()
logging.info('Modified /etc/hosts, added: %s' %entry)

# Create location to store data if it does not exist
if not os.path.exists(regDataDir):
    os.system('mkdir -p %s' %regDataDir)

# Write the data of the current target server
storeSMTData(registrationTarget)

# Check if we need to send along any instance data
instDataFilePath = '/var/lib/cloudregister/' + str(uuid.uuid4())
if cfg.has_section('instance'):
    if cfg.has_option('instance', 'dataProvider'):
        cmdLn = cfg.get('instance', 'dataProvider')
        if cmdLn != 'none':
            cmd = cmdLn.split()[0]
            if cmd[0] != '/':
                try:
                    p = subprocess.Popen(
                        ['which %s' %cmd],
                        stdout=subprocess.PIPE,
                        stderr=subprocess.PIPE,
                        close_fds=True
                    )
                except:
                    errMsg = 'Could not find configured dataProvider: %s' %cmd
                    logging.error(errMsg)
            if os.access(cmd, os.X_OK):
                os.system("%s > %s" %(cmdLn, instDataFilePath))
            else:
                msg = 'Configured dataProvider "%s" is not executable' %cmd
                logging.error(msg)

register11 = '/usr/lib/suseRegister/bin/clientSetup4SMT.sh'
register12 = '/usr/sbin/SUSEConnect'
if (os.path.exists(register11) and os.access(register11, os.X_OK)):
    cmd = register11
    cmd += ' --host %s ' %registrationTarget.getFQDN()
    cmd += '--fingerprint %s ' %registrationTarget.getFingerprint()
    cmd += '--yes '

    if os.path.exists(instDataFilePath):
        cmd += '--regdata %s' %instDataFilePath

    if forceNewRegistration:
        cmd += ' > /dev/null 2>&1'

    logging.info('Registration: %s' %cmd)
    res = os.system(cmd)

    if res:
        logging.error('Registration failed')
        sys.exit(1)

    # registration was successful, let's check if the repos do
    # really exist and if not complete the registration by calling
    # suse_register with the restore-repos option
    reposExist = hasRepos(registrationTarget.getFQDN())
    if not reposExist:
        cmd = "suse_register --restore-repos"
        res = os.system(cmd)

    if res:
        logging.info('Repositories were not restored')

elif (os.path.exists(register12) and os.access(register12, os.X_OK)):
    # get product list
    products = getProducts()
    if not len(products):
        logging.error('No products found')
        sys.exit(1)

    smtCA_request = getSMTCert(registrationTarget.getFQDN())
    if not smtCA_request:
        sys.exit(1)

    if not x509FingerPrintValid(smtCA_request,
                                registrationTarget.getFingerprint()):
        logging.error('SMT certificate fingerprint verification failed')
        sys.exit(1)

    if not importCA(smtCA_request):
        logging.error('SMT certificate import failed')
        sys.exit(1)

    # Register the base product first
    cmd = [register12, '--url', 'https://%s ' %registrationTarget.getFQDN()]
    if os.path.exists(instDataFilePath):
        cmd.append(' --instance-data')
        cmd.append(instDataFilePath)
    p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    res = p.communicate()
    for entry in res:
        if entry.find('error') != -1:
            logging.error('Baseproduct registration failed')
            logging.error('\t%s' %entry)
            sys.exit(1)
        
    for product in products:
        cmd = register12
        cmd += ' --url https://%s ' %registrationTarget.getFQDN()
        cmd += ' --product %s ' %product
        if os.path.exists(instDataFilePath):
            cmd += ' --instance-data %s ' %instDataFilePath

        logging.info('Registration: %s' %cmd)
        res = os.system(cmd)

        if res:
            logging.error('Registration failed')
            sys.exit(1)

else:
    logging.error('No registration executable found')
    sys.exit(1)

if os.path.exists(instDataFilePath):
    os.unlink(instDataFilePath)
